---
title: "Assignment 1"
author: "Tanner Bivins, Emmett Saulnier, Brock Wilson"
date: "4/29/2021"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(pacman)
p_load(here, rddensity, data.table, ggplot2)
```

For this problem you will estimate a regression discontinuity design to test whether having a BAC over the legal limits. You can compare this to the paper by yours truly about DUI punishments we read earlier.

a. Create a histogram of the running variable, BAC. Make sure you do it allowing for discrete bins. Is there evidence of clear sorting at the threshold?

#### Solution

There doesn't seem to be sorting at the threshold.

```{R}
# Loading Data
bac = data.table(read.csv(here("bac.csv")))

# Histogram of BAC
ggplot(data = bac, aes(x = bac)) +
  geom_histogram(binwidth = 0.001) +
  geom_vline(xintercept = 0.08, alpha = 0.7) +
  geom_vline(xintercept = 0.15, alpha = 0.7) 

# add title and x axis and y axis labels
```

b. Get the R package rddensity. Perform a density test on the running variable. Is there evidence of sorting?

#### Solution

```{R}

rd_dens = rddensity(X = bac$bac, c = 0.08, kernel = "uniform")
summary(rd_dens)
rd_dens$test
```

c. Next run a regression discontinuity model. To do so, create a dummy variable for a BAC over .08. Include that dummy variable, and the rescaled BAC (BAC-.08) as a control, and also include an interaction between that dummy variable and the running variable in model. First use age, gender, accident at the scene and race as outcomes. Do those factors shift at .08?

#### Solution

```{R}
bac$drunk = ifelse(bac$bac > 0.08, 1, 0)
bac$rescaled_bac = bac$bac - 0.08

# Regressions to see if there is sorting on either side of the cutoff
mod_aged = lm(data = bac, aged ~ drunk + rescaled_bac + drunk*rescaled_bac)
mod_male = lm(data = bac, male ~ drunk + rescaled_bac + drunk*rescaled_bac)
mod_acc = lm(data = bac, acc ~ drunk + rescaled_bac + drunk*rescaled_bac)

library(modelsummary)

modelsummary(models = list(mod_aged, mod_male, mod_acc))

bac$fitaged = predict(mod_aged)
bac$fitmale = predict(mod_male)
bac$fitacc = predict(mod_acc)

# Binning

bac$bac_bins = cut(bac$rescaled_bac, breaks = seq(-0.082, 0.36, 0.002), ordered_result = TRUE)

bac_average = bac[, 
    lapply(.SD, mean, na.rm =TRUE),
    .SDcols = c("aged","male","acc", "fitaged", "fitmale", "fitacc"),
    by = bac_bins]

##################

library(stringr)
library(tidyr)
bac_average = bac_average %>% separate((bac_bins), c("a", "b"),sep = ",")
bac_average$cont_bin = as.numeric(str_sub(bac_average$a, start = 2))

# Plots to visually see sorting
ggplot(data = bac_average, aes(x = cont_bin, y = aged)) +
  geom_point(shape = 1) +
  geom_line(data = bac_average[cont_bin < 0,], aes(y = fitaged), color = "red") +
  geom_line(data = bac_average[cont_bin > 0,], aes(y = fitaged), color = "red") 

ggplot(data = bac_average, aes(x = cont_bin, y = acc)) +
  geom_point(shape = 1) +
  geom_line(data = bac_average[cont_bin < 0,], aes(y = fitacc), color = "red") +
  geom_line(data = bac_average[cont_bin > 0,], aes(y = fitacc), color = "red") 

ggplot(data = bac_average, aes(x = cont_bin, y = male)) +
  geom_point(shape = 1) +
  geom_line(data = bac_average[cont_bin < 0,], aes(y = fitmale), color = "red") +
  geom_line(data = bac_average[cont_bin > 0,], aes(y = fitmale), color = "red") 
```

d. Now run a regression of recidivism on the same regression discontinuity design. What is your estimated effect using a bandwidth of .05, and a rectangular kernel (no weighting). Create a visualization of this by graphing the mean recidivism rate against the running variable. Show this for the whole BAC distribution, and the range from .03 to .13. Please include a fitted line.

#### Solution

```{R}

bac2 = bac[rescaled_bac <= 0.05 & rescaled_bac >= -0.05,]

mod_recid = (lm(data = bac2, 
           recidivism ~ drunk*rescaled_bac + aged + male + acc))

mod_recid2 = (lm(data = bac2, 
           recidivism ~ drunk*rescaled_bac))

modelsummary(models = list(mod_recid, mod_recid2))

bac2$fitrecid = predict(mod_recid)

#### Graphing mean recidivism

# Binning

bac$bac_bins = cut(bac$rescaled_bac, breaks = seq(-0.082, 0.36, 0.002), ordered_result = TRUE)
bac2$bac_bins = cut(bac2$rescaled_bac, breaks = seq(-0.082, 0.36, 0.002), ordered_result = TRUE)

bac_average = bac[, 
    lapply(.SD, mean, na.rm =TRUE),
    .SDcols = c("recidivism"),
    by = bac_bins]

bac_average2 = bac2[, 
    lapply(.SD, mean, na.rm =TRUE),
    .SDcols = c("fitrecid"),
    by = bac_bins]

#######
for (x in seq(-0.082, 0.36, 0.002)) {
  bac[rescaled_bac >= x & rescaled_bac < x + .002, bac_bin := x]
}
######
library(stringr)
library(tidyr)
bac_average = bac_average %>% separate((bac_bins), c("a", "b"),sep = ",")
bac_average$cont_bin = as.numeric(str_sub(bac_average$a, start = 2))

bac_average2 = bac_average2 %>% separate((bac_bins), c("a", "b"),sep = ",")
bac_average2$cont_bin = as.numeric(str_sub(bac_average2$a, start = 2))


# Plots to visually see sorting
ggplot(data = bac_average[cont_bin < 0.2], aes(x = cont_bin, y = recidivism)) +
  geom_point(shape = 1) +
  geom_line(data = bac_average2[cont_bin < 0,], aes(y = fitrecid), color = "red") +
  geom_line(data = bac_average2[cont_bin > 0,], aes(y = fitrecid), color = "red") 

```

e. Do the same thing as part c and d but for the aggravated threshold of .151.

#### Solution

```{R}
####### PART C
bac = data.table(read.csv(here("bac.csv")))

bac$drunk_agg = ifelse(bac$bac > 0.151, 1, 0)
bac$rescaled_bac = bac$bac - 0.151

# Regressions to see if there is sorting on either side of the cutoff
mod_aged = lm(data = bac, aged ~ drunk_agg + rescaled_bac + drunk_agg*rescaled_bac)
mod_male = lm(data = bac, male ~ drunk_agg + rescaled_bac + drunk_agg*rescaled_bac)
mod_acc = lm(data = bac, acc ~ drunk_agg + rescaled_bac + drunk_agg*rescaled_bac)

modelsummary(models = list(mod_aged, mod_male, mod_acc))

bac$fitaged = predict(mod_aged)
bac$fitmale = predict(mod_male)
bac$fitacc = predict(mod_acc)

# Binning

bac$bac_bins = cut(bac$rescaled_bac, breaks = seq(-0.152, 0.29, 0.002), ordered_result = TRUE)

bac_average = bac[, 
    lapply(.SD, mean, na.rm =TRUE),
    .SDcols = c("aged","male","acc", "fitaged", "fitmale", "fitacc"),
    by = bac_bins]

##################

library(stringr)
library(tidyr)
bac_average = bac_average %>% separate((bac_bins), c("a", "b"),sep = ",")
bac_average$cont_bin = as.numeric(str_sub(bac_average$a, start = 2))

# Plots to visually see sorting
# ggplot(data = bac_average, aes(x = cont_bin, y = aged)) +
#   geom_point(shape = 1) +
#   #geom_line(data = bac_average[cont_bin < 0,], aes(y = fitaged), color = "red") +
#   #geom_line(data = bac_average[cont_bin > 0,], aes(y = fitaged), color = "red") + 
#   geom_smooth(data = bac_average[cont_bin < 0,], method = "lm") +
#   geom_smooth(data = bac_average[cont_bin > 0,], method = "lm")
# 
ggplot(data = bac_average, aes(x = cont_bin, y = aged)) +
  geom_point(shape = 1) +
  geom_line(data = bac_average[cont_bin < 0,], aes(y = fitaged), color = "red") +
  geom_line(data = bac_average[cont_bin > 0,], aes(y = fitaged), color = "red") 
  #geom_smooth(data = bac_average[cont_bin < 0,], method = "lm") +
  #geom_smooth(data = bac_average[cont_bin > 0,], method = "lm")

ggplot(data = bac_average, aes(x = cont_bin, y = acc)) +
  geom_point(shape = 1) +
  geom_line(data = bac_average[cont_bin < 0,], aes(y = fitacc), color = "red") +
  geom_line(data = bac_average[cont_bin > 0,], aes(y = fitacc), color = "red") 

ggplot(data = bac_average, aes(x = cont_bin, y = male)) +
  geom_point(shape = 1) +
  geom_line(data = bac_average[cont_bin < 0,], aes(y = fitmale), color = "red") +
  geom_line(data = bac_average[cont_bin > 0,], aes(y = fitmale), color = "red") 


###### PART D

bac2 = bac[rescaled_bac <= 0.05 & rescaled_bac >= -0.05,]

mod_recid = (lm(data = bac2, 
           recidivism ~ drunk_agg*rescaled_bac + aged + male + acc))

mod_recid2 = (lm(data = bac2, 
           recidivism ~ drunk_agg*rescaled_bac))

modelsummary(models = list(mod_recid, mod_recid2))

bac2$fitrecid = predict(mod_recid)

#### Graphing mean recidivism

# Binning

bac$bac_bins = cut(bac$rescaled_bac, breaks = seq(-0.152, 0.29, 0.002), ordered_result = TRUE)
bac2$bac_bins = cut(bac2$rescaled_bac, breaks = seq(-0.152, 0.29, 0.002), ordered_result = TRUE)

bac_average = bac[, 
    lapply(.SD, mean, na.rm =TRUE),
    .SDcols = c("recidivism"),
    by = bac_bins]

bac_average2 = bac2[, 
    lapply(.SD, mean, na.rm =TRUE),
    .SDcols = c("fitrecid"),
    by = bac_bins]

#######
for (x in seq(-0.152, 0.29, 0.002)) {
  bac[rescaled_bac >= x & rescaled_bac < x + .002, bac_bin := x]
}
######
library(stringr)
library(tidyr)
bac_average = bac_average %>% separate((bac_bins), c("a", "b"),sep = ",")
bac_average$cont_bin = as.numeric(str_sub(bac_average$a, start = 2))

bac_average2 = bac_average2 %>% separate((bac_bins), c("a", "b"),sep = ",")
bac_average2$cont_bin = as.numeric(str_sub(bac_average2$a, start = 2))


# Plots to visually see sorting
ggplot(data = bac_average[cont_bin < 0.2 & cont_bin >-0.1], aes(x = cont_bin, y = recidivism)) +
  geom_point(shape = 1) +
  geom_line(data = bac_average2[cont_bin < 0,], aes(y = fitrecid), color = "red") +
  geom_line(data = bac_average2[cont_bin > 0,], aes(y = fitrecid), color = "red") 


```

f. Now run this model for every possible bandwidth between .01 and .07. Store both the point estimates and lower and upper confidence intervals. Create a scatter plot of the confidence interval and the point estimates. Are the estimates robust? Create a visualization of this.

#### Solution

g. Finally, I want you to reestimate your models using instead of the .08 threshold, every other BAC as the threshold, keeping a bandwidth of .03, between .03 and .12 (i.e. .03, .031, .032, etc). Create a scatter plot of both the point estimates (yaxis) against the potential RD thresholds (x axis). Now create a scatter plot of your test statistic on the null hypothesis of your point estimates (z-stat/t-stat) with the test statistic on the y axis, and the threshold on the x axis. What is the rank of (1 being the largest) of your point estimate estimated at .08? How many estimates did you do? The rank divided by the number of tests is called an empirical pvalue based on a form of permutation inference.

